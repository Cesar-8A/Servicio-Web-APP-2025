{% extends "home.html" %}

{% block main_container %}
{% block content %}

<div id="viewer-wrapper">
  <div id="viewer-container">

    <div id="plugins-sidebar" class="bg-dark d-flex flex-column p-3 border-end border-secondary">
      <h5 class="text-light mb-3">Plugins</h5>
      
      <button id="rtStructPluginBtn" class="btn btn-secondary w-100 mb-2">
        Cargar RT Struct
      </button>
      <div id="rtStructPluginContainer" class="w-100 mb-3" style="display: none;">
        <form id="rtStructForm" action="/upload_RT" method="post" enctype="multipart/form-data" class="d-flex flex-column gap-2 w-100 mt-2">
          <input type="hidden" name="csrf_token" value="{{ csrf_token() }}">
          <input type="file" name="file" accept=".nrrd" class="form-control" required>
          <button type="submit" class="btn btn-udg-dorado shadow-sm w-100"><i class="bi bi-upload"></i> Subir</button>
        </form>
      </div>
      
      <button id="huPickerPluginBtn" class="btn btn-secondary w-100 mb-2">
        Selector HU
      </button>
      <div id="huPickerPluginContainer" class="w-100 mb-3" style="display: none;">
        <small id="huInfo" class="text-secondary d-block mt-2"></small>
        <div id="huResult" class="small text-warning mt-1"></div>
      </div>

      <button id="huToggle" style="display: none;">Activar Selector HU</button>
    </div>

    <div id="quadrant-grid-wrapper">
      {% if success == 0 %}
        <div class="d-flex h-100 align-items-center justify-content-center">
          <h1 class="text-light">Carga primero una imagen</h1>
        </div>
      {% else %}
        <div id="quadrant-grid">
          {% set views = [('axial', max_value_axial), ('sagital', max_value_sagital), ('coronal', max_value_coronal), ('3D', None)] %}
          {% for view, max_val in views %}
            <div id="card_{{ view }}" class="card bg-dark text-light border-secondary shadow-sm quadrant-card">
              <div class="card-body p-2">
                <div class="d-flex justify-content-between align-items-center mb-1">
                  <h6 class="card-title mb-0 ms-2">Vista {{ view|upper }}</h6>
                  <button type="button" class="btn btn-sm btn-outline-light" onclick="toggleFullscreen('card_{{ view }}')"><i class="bi bi-arrows-fullscreen"></i></button>
                </div>
                {% if view != '3D' %}
                <div class="d-flex gap-2 align-items-center px-2">
                  <input type="range" id="slider_{{ view }}" min="0" max="{{ max_val }}" value="{{ max_val // 2 }}" class="form-range">
                  <input type="number" id="number_{{ view }}" min="0" max="{{ max_val }}" value="{{ max_val // 2 }}" class="form-control form-control-sm" style="width: 70px;">
                </div>
                <div class="image-wrapper mt-1">
                  <img id="image_{{ view }}" src="/image/{{ view }}/{{ max_val // 2 }}" class="rounded" alt="{{ view }}" />
                  <canvas id="overlay_{{ view }}" style="pointer-events:none;"></canvas>
                </div>
                {% else %}
                <div class="iframe-wrapper mt-1">
                  <iframe src="http://127.0.0.1:5010/panel" id="DicomRender" class="rounded" allowfullscreen></iframe>
                </div>
                {% endif %}
              </div>
            </div>
          {% endfor %}
        </div>
      {% endif %}
    </div>
  </div>
</div>

<script>
// --- SE AÑADE EL EVENT LISTENER PARA ESPERAR A QUE CARGUE EL DOCUMENTO ---
document.addEventListener('DOMContentLoaded', function() {

  // --- LÓGICA DE PLUGINS Y HU PICKER ---
  function setupPluginButton(btnId, containerId, onToggleCallback) {
    const btn = document.getElementById(btnId);
    const container = document.getElementById(containerId);
    let isActive = false;
    btn.addEventListener('click', () => {
      isActive = !isActive;
      btn.classList.toggle('btn-secondary', !isActive);
      btn.classList.toggle('btn-udg-rojo', isActive);
      container.style.display = isActive ? 'block' : 'none';
      if (onToggleCallback) { onToggleCallback(isActive); }
    });
  }
  setupPluginButton('rtStructPluginBtn', 'rtStructPluginContainer');
  const huToggle_hiddenButton = document.getElementById('huToggle');
  setupPluginButton('huPickerPluginBtn', 'huPickerPluginContainer', () => {
    huToggle_hiddenButton.click();
  });

  const huInfo = document.getElementById("huInfo");
  const huResult = document.getElementById("huResult");
  let huMode = false;

  function syncCanvasToImage(imgEl, canvasEl) { const dpr = window.devicePixelRatio || 1; const rect = imgEl.getBoundingClientRect(); canvasEl.width = Math.max(1, Math.round(rect.width * dpr)); canvasEl.height = Math.max(1, Math.round(rect.height * dpr)); const ctx = canvasEl.getContext("2d"); ctx.setTransform(1, 0, 0, 1, 0, 0); ctx.scale(dpr, dpr); ctx.clearRect(0, 0, canvasEl.width, canvasEl.height); return ctx; }
  function drawMarker(ctx, xCss, yCss) { ctx.fillStyle = "red"; ctx.beginPath(); ctx.arc(xCss, yCss, 5 / (window.devicePixelRatio || 1), 0, 2 * Math.PI); ctx.fill(); }
  function cssToPngPixels(imgEl, evt) { const rect = imgEl.getBoundingClientRect(); const nW = imgEl.naturalWidth; const nH = imgEl.naturalHeight; const dispW = rect.width; const dispH = rect.height; const scaleX = nW / dispW; const scaleY = nH / dispH; const xCss = evt.clientX - rect.left; const yCss = evt.clientY - rect.top; if (xCss < 0 || yCss < 0 || xCss > dispW || yCss > dispH) return null; const xPix = Math.floor(xCss * scaleX); const yPix = Math.floor(yCss * scaleY); return { xPix, yPix, xCss, yCss }; }
  
  function bindHU(view) {
    const img = document.getElementById(`image_${view}`);
    const canvas = document.getElementById(`overlay_${view}`);
    let ctx = null;
    function resetCanvas() { ctx = syncCanvasToImage(img, canvas); }
    img.addEventListener("load", resetCanvas);
    new ResizeObserver(resetCanvas).observe(img);
    img.addEventListener("click", (evt) => {
      if (!huMode) return;
      resetCanvas();
      const mapped = cssToPngPixels(img, evt);
      if (!mapped) { huResult.textContent = "Clicked outside image."; return; }
      const slider = document.getElementById(`slider_${view}`);
      const idx = parseInt(slider.value, 10);
      fetch(`/hu_value?view=${view}&x=${mapped.xPix}&y=${mapped.yPix}&index=${idx}`)
        .then(r => r.json())
        .then(data => {
          if (data.error) {
            huResult.textContent = "Error: " + data.error;
            return;
          }
          huResult.innerHTML = `Voxel (X, Y, Z): ${data.voxel.x}, ${data.voxel.y}, ${data.voxel.z}<br>Valor HU: ${data.hu}`;
          drawMarker(ctx, mapped.xCss, mapped.yCss);
        }).catch(() => { huResult.textContent = "Error fetching HU value."; });
    });
  }
  
  huToggle_hiddenButton.addEventListener("click", () => {
    huMode = !huMode;
    huInfo.textContent = huMode ? "Haz click dentro de cualquier imagen para obtener las HU." : "";
    if (!huMode) {
      ["axial", "sagital", "coronal"].forEach(v => {
        const img = document.getElementById(`image_${v}`);
        const canvas = document.getElementById(`overlay_${v}`);
        syncCanvasToImage(img, canvas);
      });
    }
  });

  ["axial", "sagital", "coronal"].forEach(bindHU);

  // --- LÓGICA DE SLIDERS ---
  function setupSlider(view) {
    const slider = document.getElementById(`slider_${view}`);
    const number = document.getElementById(`number_${view}`);
    const image = document.getElementById(`image_${view}`);
    function updateImage(layer) { image.src = `/image/${view}/${layer}?t=${new Date().getTime()}`; }
    slider.addEventListener('input', () => { number.value = slider.value; updateImage(slider.value); });
    number.addEventListener('input', () => { let val = Number(number.value); if (val < slider.min) val = slider.min; if (val > slider.max) val = slider.max; slider.value = val; updateImage(val); });
  }
  setupSlider('axial');
  setupSlider('sagital');
  setupSlider('coronal');

  // --- LÓGICA DE FULLSCREEN Y FORMULARIO ---
  document.addEventListener('fullscreenchange', () => { if (!document.fullscreenElement) { document.querySelector('.fullscreen')?.classList.remove('fullscreen'); } });
  const rtStructForm = document.getElementById('rtStructForm'); if (rtStructForm) { rtStructForm.addEventListener("submit", function (event) { event.preventDefault(); let formData = new FormData(this); const token = document.querySelector('meta[name="csrf-token"]').content; fetch("/upload_RT", { method: "POST", headers: { 'X-CSRFToken': token }, body: formData }).then(() => { alert("Archivo cargado correctamente."); }); }); }

}); // --- CIERRE DEL DOMCONTENTLOADED ---

// La función de fullscreen debe estar en el scope global para que el 'onclick' la encuentre
function toggleFullscreen(id) {
  const element = document.getElementById(id);
  if (!document.fullscreenElement) {
    element.requestFullscreen().catch(err => {
      alert(`Error al entrar en pantalla completa: ${err.message}`);
    });
  } else {
    document.exitFullscreen();
  }
}
</script>

{% endblock content %}
{% endblock main_container %}